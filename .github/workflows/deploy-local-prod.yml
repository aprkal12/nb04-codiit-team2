name: Deploy to AWS (single server)

on:
  push: 
    branches:
      - experiment/redis

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}
  IMAGE_TAG: ${{ github.sha }}

jobs:
  deploy:
    runs-on: ubuntu-latest
  
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}
      
      # ============================================
      # Step 1: EC2 Public IP ë™ì  ì¡°íšŒ
      # ============================================
      - name: Get EC2 Public IP
        id: get-ip
        run: |
          echo "ğŸ” Getting Public IP for ${{ steps.ec2-setup.outputs.instance_id }}..."

          # 1. íƒœê·¸(Name=codiit-dev)ì™€ ìƒíƒœ(running)ë¡œ IP ì¡°íšŒ
          PUBLIC_IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=codiit-dev" \
                      "Name=instance-state-name,Values=running" \
            --query 'Reservations[0].Instances[0].PublicIpAddress' \
            --output text)

          # 2. IPë¥¼ ëª» ì°¾ì•˜ì„ ê²½ìš° ì—ëŸ¬ ì²˜ë¦¬
          if [[ "$PUBLIC_IP" == "None" || -z "$PUBLIC_IP" ]]; then
            echo "âŒ Error: ì‹¤í–‰ ì¤‘ì¸ 'codiit-dev' ì„œë²„ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            exit 1
          fi
        
          echo "âœ… ì°¾ì€ Public IP: $PUBLIC_IP"
            
          # 3. ë‹¤ìŒ ë‹¨ê³„ì—ì„œ ì“¸ ìˆ˜ ìˆë„ë¡ ì¶œë ¥ ë³€ìˆ˜ì— ì €ì¥
          echo "public_ip=$PUBLIC_IP" >> $GITHUB_OUTPUT
      
      # ============================================
      # Step 2: Docker ì´ë¯¸ì§€ ë¹Œë“œ ë° ECR í‘¸ì‹œ
      # ============================================
      - name: Login to AWS ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push Docker image
        run: |
          echo "ğŸ”¨ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG \
                    $ECR_REGISTRY/$ECR_REPOSITORY:latest
          
          echo "ğŸ“¤ Pushing to ECR..."
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          echo "âœ… Image pushed: $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"

      # ============================================
      # Step 3: EC2ì— ë°°í¬ (SSH)
      # ============================================
      # sk broadband ì¸í„°ë„·ì€ 22ë²ˆ í¬íŠ¸ê°€ ì°¨ë‹¨ë˜ì–´ ìˆìŒ
      # ec2ì˜ ssh í¬íŠ¸ë¥¼ 2222ë²ˆ í¬íŠ¸ë¡œ ë³€ê²½í•¨
      - name: Setup SSH key
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/codiit-key.pem
          chmod 400 ~/.ssh/codiit-key.pem
          ssh-keyscan -p 2222 -H ${{ steps.get-ip.outputs.public_ip }} >> ~/.ssh/known_hosts 2>/dev/null
      
      - name: Create .env file locally
        run: |
          echo "ğŸ“ Creating .env file locally..."
          cat > .env.production << 'EOF'
          # APP config
          NODE_ENV=${{ secrets.NODE_ENV }}
          PORT=${{ secrets.PORT }}
          DATABASE_URL=${{ secrets.DATABASE_URL }}
          ACCESS_TOKEN_SECRET=${{ secrets.ACCESS_TOKEN_SECRET }}
          ACCESS_TOKEN_EXPIRES_IN=15m
          REFRESH_TOKEN_SECRET=${{ secrets.REFRESH_TOKEN_SECRET }}
          REFRESH_TOKEN_EXPIRES_IN=7d
          CORS_ORIGIN=${{ secrets.CORS_ORIGIN }}
          BCRYPT_ROUNDS=10
          PORTONE_API_KEY=${{ secrets.PORTONE_API_KEY }}
          PORTONE_API_SECRET=${{ secrets.PORTONE_API_SECRET }}
          REDIS_URL=${{ secrets.REDIS_URL }}
          SLOW_QUERY_THRESHOLD_MS=${{ secrets.SLOW_QUERY_THRESHOLD_MS }}
          RATE_LIMIT_WINDOW=${{ secrets.RATE_LIMIT_WINDOW }}
          RATE_LIMIT_MAX=${{ secrets.RATE_LIMIT_MAX }}
          RATE_LIMIT_AUTH_LOGIN_WINDOW=${{ secrets.RATE_LIMIT_AUTH_LOGIN_WINDOW }}
          RATE_LIMIT_AUTH_LOGIN_MAX=${{ secrets.RATE_LIMIT_AUTH_LOGIN_MAX }}
          RATE_LIMIT_AUTH_REFRESH_WINDOW=${{ secrets.RATE_LIMIT_AUTH_REFRESH_WINDOW }}
          RATE_LIMIT_AUTH_REFRESH_MAX=${{ secrets.RATE_LIMIT_AUTH_REFRESH_MAX }}
          # AWS config
          # AWS_ACCESS_KEY, SECRET ëŒ€ì‹  ec2ì— ì§ì ‘ iam roleì„ ì§€ì •í•´ì„œ ì‚¬ìš©
          AWS_REGION=${{ env.AWS_REGION }}
          AWS_S3_BUCKET=${{ secrets.AWS_S3_BUCKET }}
          ECR_REGISTRY=${{ env.ECR_REGISTRY }}
          ECR_REPOSITORY=${{ env.ECR_REPOSITORY }}
          IMAGE_TAG=${{ env.IMAGE_TAG }}
          EOF
          echo "âœ… .env file created"
      
      - name: Transfer .env to EC2
        run: |
          echo "ğŸ“¤ Transferring .env to EC2..."
          scp -i ~/.ssh/codiit-key.pem -P 2222 .env.production docker-compose.yml \
            ec2-user@${{ steps.get-ip.outputs.public_ip }}:/home/ec2-user/

          # ì´ë¦„ ë³€ê²½ (.env.production -> .env)
          ssh -i ~/.ssh/codiit-key.pem -p 2222 ec2-user@${{ steps.get-ip.outputs.public_ip }} "mv /home/ec2-user/.env.production /home/ec2-user/.env"
          
          # ë¡œì»¬ .env ì‚­ì œ (ë³´ì•ˆ)
          rm -f .env.production

          echo "âœ… .env file transferred securely"
      
      - name: Deploy Docker compose on EC2
        run: |
          echo "ğŸš€ Deploying to EC2..."

          ssh -i ~/.ssh/codiit-key.pem -p 2222 ec2-user@${{ steps.get-ip.outputs.public_ip }} \
              "AWS_REGION=$AWS_REGION \
              ECR_REGISTRY=$ECR_REGISTRY \
              bash -s" << 'DEPLOYSSH'
          
          # 1. ECR ë¡œê·¸ì¸
          aws ecr get-login-password --region $AWS_REGION | \
              docker login --username AWS --password-stdin $ECR_REGISTRY
          
          # 2. ì´ë¯¸ì§€ Pull
          echo "ğŸ“¥ Pulling new image..."
          docker compose pull

          # 3. docker compose ì‹¤í–‰
          echo "ğŸ”„ Restarting containers..."
          docker compose up -d --remove-orphans

          # 4. Prisma ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰
          echo "ğŸ”„ Running Prisma migrations..."
          docker compose run --rm api-server ./node_modules/.bin/prisma migrate deploy

          if [ $? -ne 0 ]; then
             echo "âŒ Migration failed!"
             docker compose logs --tail 50
             exit 1
          fi

          echo "âœ… Migrations completed"

          # 5. í—¬ìŠ¤ì²´í¬ (API ì„œë²„)
          echo "ğŸ¥ Health checking..."
          for i in {1..12}; do
            if curl -f http://localhost:3000/api/health > /dev/null 2>&1; then
              echo "âœ… Health check passed!"
              docker logout $ECR_REGISTRY || true
              exit 0
            fi
            sleep 5
          done
          
          echo "âŒ Health check failed!"
          docker compose logs --tail 50
          exit 1
          DEPLOYSSH

          echo "âœ… Deployment on EC2 successful!"

      # ============================================
      # ì •ë¦¬: ì‚¬ìš©í•˜ì§€ ì•ŠëŠ” Docker ì´ë¯¸ì§€ ì‚­ì œ
      # ============================================
      - name: Cleanup old Docker images
        if: success()
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ steps.get-ip.outputs.public_ip }}
          username: ec2-user
          key: ${{ secrets.EC2_SSH_KEY }}
          script: |
            echo "ğŸ§¹ Cleaning up unused Docker images..."
            
            # 24ì‹œê°„ ì§€ë‚œ ë¯¸ì‚¬ìš© ì´ë¯¸ì§€ë§Œ ì‚­ì œ
            docker image prune -af --filter "until=24h"
            
            echo "âœ… Cleanup completed"

      # ============================================
      # Discord ì•Œë¦¼
      # ============================================
      - name: Send Discord notification on success
        if: success()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          title: "âœ… í”„ë¡œë•ì…˜ ë°°í¬ ì„±ê³µ!"
          description: |
              - ğŸŒ¿ **ë¸Œëœì¹˜**: ${{ github.ref_name }}
              - ğŸš€ **ë°°í¬ í™˜ê²½**: Production (Single Instance)
              - ğŸ–¥ï¸ **ì„œë²„ IP**: ${{ steps.get-ip.outputs.public_ip }}
              - ğŸ³ **ì´ë¯¸ì§€ íƒœê·¸**: ${{ github.sha }}
              - ğŸ‘¤ **ë°°í¬ì**: ${{ github.actor }}
          color: 0x00FF00
          username: GitHub Actions
          avatar_url: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png

      - name: Send Discord notification on failure
        if: failure()
        uses: sarisia/actions-status-discord@v1
        with:
          webhook: ${{ secrets.DISCORD_WEBHOOK_URL }}
          title: "âŒ í”„ë¡œë•ì…˜ ë°°í¬ ì‹¤íŒ¨!"
          description: |
            - ğŸŒ¿ **ë¸Œëœì¹˜**: ${{ github.ref_name }}
            - ğŸš¨ **ì‹¤íŒ¨ ë‹¨ê³„**: Workflow ë¡œê·¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.
            - ğŸ–¥ï¸ **ëŒ€ìƒ ì„œë²„**: ${{ steps.get-ip.outputs.public_ip }}
            - ğŸ‘¤ **ë°°í¬ì**: ${{ github.actor }}
          color: 0xFF0000
          username: GitHub Actions
          avatar_url: https://github.githubassets.com/images/modules/logos_page/GitHub-Mark.png

